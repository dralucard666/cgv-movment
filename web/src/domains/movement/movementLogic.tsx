/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three"
import React, { Suspense, useEffect, useLayoutEffect, useMemo, useRef, useState } from "react"
import { useGLTF, useAnimations } from "@react-three/drei"
import { GLTF, SkeletonUtils } from "three-stdlib"
import { AnimationClip, Group, RingGeometry } from "three"
import { extend, useFrame, useGraph } from "@react-three/fiber"
import { movObject, useMovementStore } from "./useMovementStore"
import { Cyclist } from "./cyclist"
import { ObjectType } from "cgv/domains/movement"
import { TextComponent } from "./text"
import { Truck } from "./truck"
import { Person } from "./person"
import { Marker } from "./marker"

const extraData = {
    pedestrian: {
        lineOffsetX: 0,
        lineOffsetY: 15,
        lineLength: 50,
        textMarginX: -10,
        textMarginY: 45,
        rotationY: Math.PI / 2,
    },
    cyclist: {
        lineOffsetX: 0,
        lineOffsetY: 15,
        lineLength: 50,
        textMarginX: -10,
        textMarginY: 60,
        rotationY: Math.PI / 2,
    },
    truck: {
        lineOffsetX: 50,
        lineOffsetY: 20,
        lineLength: 120,
        textMarginX: -10,
        textMarginY: 60,
        rotationY: Math.PI,
    },
}

export default function MovementLogic(props: { id: string; data: movObject }) {
    const object = useRef<any>()
    const text = useRef<any>()
    const marker = useRef<any>()

    const type = props.data.type
    const testType: ObjectType = ObjectType.Pedestrian as ObjectType

    const isMarked = true

    const [lineOffsetX, lineOffsetY, lineLength, textMarginX, textMarginY, rotationY] = getExtraData(testType)
    const PersonComp = useMemo(() => {
        switch (testType) {
            case ObjectType.Cyclist:
                return <Cyclist key={props.id} id={props.id} ref={object}></Cyclist>
            case ObjectType.Pedestrian:
                return <Person key={props.id} id={props.id} ref={object}></Person>
            case ObjectType.Car:
                return <Truck key={props.id} id={props.id} ref={object}></Truck>
            default:
                return <Person key={props.id} id={props.id} ref={object}></Person>
        }
    }, [props])
    const line = useRef<any>()

    const data = props.data

    useEffect(() => {
        if (object.current && data.framePos.length > 0) {
            const firstPos = data.framePos[0]
            if (firstPos.position) {
                const x = firstPos.position[0]
                const y = firstPos.position[1]
                const z = firstPos.position[2]
                object.current.updatePosition(x, y, z, rotationY, 0)
                text.current.updatePosition(x + textMarginX, y + textMarginY, z)
            }
        }
    }, [object, props])

    useFrame((state, delta) => {
        const currentTime = useMovementStore.getState().time

        if (data.startT <= currentTime && currentTime <= data.endT && data.framePos) {
            const arrayIndex = currentTime - data.startT
            const currentLine = data.framePos[arrayIndex]
            const direction = currentLine.direction
            if (currentLine.position && object.current && line.current && direction) {
                const positionX = currentLine.position[0]
                const positionY = currentLine.position[1]
                const positionZ = currentLine.position[2]

                const angle = -Math.atan2(direction[2], direction[0]) + rotationY
                object.current.updatePosition(positionX, positionY, positionZ, angle, delta)
                text.current.updatePosition(positionX + textMarginX, positionY + textMarginY, positionZ)
                if (isMarked) {
                    marker.current.updatePosition(positionX, positionY, positionZ)
                }

                const oldLinePos = [positionX, lineOffsetY, positionZ]
                const newLinePos = [
                    positionX + direction[0] * lineLength,
                    lineOffsetY + 2,
                    positionZ + direction[2] * lineLength,
                ]
                line.current.geometry.setFromPoints(
                    [oldLinePos, newLinePos].map((point) => new THREE.Vector3(...point))
                )
            }
        }
    })

    return (
        <>
            <TextComponent {...{ text: props.id }} ref={text} />
            {isMarked ? <Marker type={testType} ref={marker} /> : null}
            <Suspense fallback={null}>{PersonComp}</Suspense>
            <line ref={line}>
                <bufferGeometry />
                <lineBasicMaterial attach="material" color={"#9c88ff"} linewidth={100} />
            </line>
        </>
    )
}

function getExtraData(type: ObjectType): [number, number, number, number, number, number] {
    switch (type) {
        case ObjectType.Cyclist:
            return [
                extraData.cyclist.lineOffsetX,
                extraData.cyclist.lineOffsetY,
                extraData.cyclist.lineLength,
                extraData.cyclist.textMarginX,
                extraData.cyclist.textMarginY,
                extraData.cyclist.rotationY,
            ]
        case ObjectType.Pedestrian:
            return [
                extraData.pedestrian.lineOffsetX,
                extraData.pedestrian.lineOffsetY,
                extraData.pedestrian.lineLength,
                extraData.pedestrian.textMarginX,
                extraData.pedestrian.textMarginY,
                extraData.pedestrian.rotationY,
            ]
        case ObjectType.Car:
            return [
                extraData.truck.lineOffsetX,
                extraData.truck.lineOffsetY,
                extraData.truck.lineLength,
                extraData.truck.textMarginX,
                extraData.truck.textMarginY,
                extraData.truck.rotationY,
            ]
        default:
            return [
                extraData.pedestrian.lineOffsetX,
                extraData.pedestrian.lineOffsetY,
                extraData.pedestrian.lineLength,
                extraData.pedestrian.textMarginX,
                extraData.pedestrian.textMarginY,
                extraData.pedestrian.rotationY,
            ]
    }
}
